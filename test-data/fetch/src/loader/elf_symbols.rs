use crate::model::AddressClasses;
use crate::Interval;
use anyhow::Result;
use memory_image::MemoryImage;
use object::read::elf::{ElfFile32, FileHeader};
use object::{elf, Object};
use once_cell::sync::Lazy;
use regex::bytes::{Regex, RegexBuilder};
use std::collections::HashMap;
use tracing::{debug, warn};

#[allow(clippy::nonminimal_bool)] // it looks nicer
fn untyped_ok(name: &str) -> bool {
    if false ||
        // names for some section locations generated by linker script
        matches!(name, "__bss_start" | "_edata" | "_etext" | "_end" | "__init_array_start" | "__init_array_end" | "__data_start" | "data_start") ||
        // gdb quirk, it's just a label in the middle of some function
        name == "linux_ptrace_test_ret_to_nx_instr" ||
        // __GNU_EH_FRAME_HDR is a label in the middle of data, uninteresting
        name == "__GNU_EH_FRAME_HDR" ||
        // gcc quirk, irrelevant
        name == "_.stapsdt.base" ||
        // sometimes gcc generates this for each jump table target    
        name.starts_with(".L")
    {
        return true;
    }

    false
}

// TODO: we are kinda inventing yara here, though it's used for a bit different purpose
static KNOWN_FUNCTIONS: Lazy<HashMap<&str, Regex>> = Lazy::new(|| {
    // those were done with a disassembler open in parallel, so these are not some magic words
    // they are just basic GCC runtime functions as found in debian's crt1.o, Scrt1.o, crti.o, crtn.o, crtbegin.o, crtbeginS.o
    // see https://stackoverflow.com/questions/22160888/what-is-the-difference-between-crtbegin-o-crtbegint-o-and-crtbegins-o for some insight into what the fuck are those
    HashMap::from(
        [
            (
                // here we technically include two functions, (_start and its own version of __x86.get_pc_thunk.bx)
                // they are always together and the latter does not have a symbol in the symbol table
                // so this is kinda required ig
                "_start",
                r#"
                \x31\xED \x5E \x89\xE1 \x83\xE4\xF0 \x50 \x54 \x52 
                \x68.... \x68.... \x51 \x56 \x68.... \xE8.... \xF4
            |
                \x31\xED \x5E \x89\xE1 \x83\xE4\xF0 \x50 \x54 \x52 
                \xE8\x22\x00\x00\x00 \x81\xC3.... \x8D\x83....
                \x50 \x8D\x83 .... \x50 \x51 \x56 \xFF\xB3....
                \xE8.... \xF4
                \x8B\x1C\x24\xC3
            "#,
            ),
            ("__x86.get_pc_thunk.ax", r#"\x8B\x04\x24\xC3"#),
            ("__x86.get_pc_thunk.bx", r#"\x8B\x1C\x24\xC3"#),
            ("__x86.get_pc_thunk.cx", r#"\x8B\x0C\x24\xC3"#),
            ("__x86.get_pc_thunk.dx", r#"\x8B\x14\x24\xC3"#),
            ("__x86.get_pc_thunk.bp", r#"\x8B\x2C\x24\xC3"#),
            ("__x86.get_pc_thunk.si", r#"\x8B\x34\x24\xC3"#),
            ("__x86.get_pc_thunk.di", r#"\x8B\x3C\x24\xC3"#),
            // first - non-PIC version, then the PIC one
            (
                "deregister_tm_clones",
                r#"
                # debian jessie, gcc 4.9.2, noPIC
                \xB8.... \x2D.... \x83\xF8\x06 \x76\x1A
                \xB8\x00\x00\x00\x00 \x85\xC0 \x74\x11
                \x55 \x89\xE5 \x83\xEC\x14 \x68.... \xFF\xD0
                \x83\xC4\x10 \xC9 \xF3\xC3
            |
                # debian jessie, gcc 4.9.2, PIC
                \x55 \x89\xE5 \x53 \xE8....
                \x81\xC3.... \x83\xEC\x04 \x8D\x93.... \x8D\x83.... 
                \x29\xD0 \x83\xF8\x06 \x76\x13
                \x8B\x83.... \x85\xC0 \x74\x09
                \x83\xEC\x0C \x52 \xFF\xD0
                \x83\xC4\x10 \x8B\x5D\xFC \xC9 \xC3
            |
                # ubuntu xenial, gcc 5.4.0, noPIC
                \xB8.... \x2D.... \x83\xF8\x06 \x76\x1A
                \xB8.... \x85\xC0 \x74\x11 \x55
                \x89\xE5 \x83\xEC\x14 \x68.... \xFF\xD0
                \x83\xC4\x10 \xC9 \xF3\xC3
            |
                # ubuntu xenial, gcc 5.4.0, PIC
                \xE8....
                \x81\xC2.... \x8D\x8A.... \x8D\x82.... \x29\xC8 \x83\xF8\x06 \x76\x17
                ...... \x85\xC0 \x74\x0D
                \x55 \x89\xE5 \x83\xEC\x14 \x51 \xFF\xD0
                \x83\xC4\x10 \xC9 \xF3\xC3
            |
                # debian buster, gcc 8.3.0, noPIC
                \xB8.... \x3D.... \x74\x24
                \xB8.... \x85\xC0 \x74\x1B
                \x55 \x89\xE5 \x83\xEC\x14 \x68.... \xFF\xD0
                \x83\xC4\x10 \xC9 \xC3
                # padding
                \x8D\xB4\x26\x00\x00\x00\x00\x66\x90
                \xF3?\xC3
            |
                # debian buster, gcc 8.3.0, PIC
                \xE8....
                \x81\xC2.... \x8D\x8A.... \x8D\x82.... \x39\xC8 \x74\x1D
                # mov     eax, offset _ITM_deregisterTMCloneTable is transformed a lot...
                ...... \x85\xC0 \x74\x13
                \x55 \x89\xE5 \x83\xEC\x14 \x51 \xFF\xD0
                \x83\xC4\x10 \xC9 \xC3
                # padding
                \x8D\x74\x26\x00\x90
                \xF3?\xC3
            "#,
            ),
            (
                "register_tm_clones",
                r#"
                # debian jessie, gcc 4.9.2, noPIC
                \xB8.... \x2D....
                \xC1\xF8\x02 \x89\xC2 \xC1\xEA\x1F \x01\xD0 \xD1\xF8 \x74\x1B
                \xBA\x00\x00\x00\x00 \x85\xD2 \x74\x12
                \x55 \x89\xE5 \x83\xEC\x10 \x50 \x68.... \xFF\xD2
                \x83\xC4\x10 \xC9 \xF3\xC3
            |
                # debian jessie, gcc 4.9.2, PIC
                \x55 \x89\xE5 \x53 \xE8.... \x81\xC3.... \x83\xEC\x04
                \x8D\x93.... \x8D\x83.... \x29\xD0 \xC1\xF8\x02 \x89\xC1
                \xC1\xE9\x1F \x01\xC8 \xD1\xF8 \x74\x14
                \x8B\x8B.... \x85\xC9 \x74\x0A
                \x83\xEC\x08 \x50 \x52 \xFF\xD1
                \x83\xC4\x10 \x8B\x5D\xFC \xC9 \xC3
            |
                # ubuntu xenial, gcc 5.4.0, noPIC
                \xB8.... \x8B\x10 \x85\xD2 \x75\x05
                \xEB.
                # padding
                \x8D\x76\x00
                \xBA.... \x85\xD2 \x74\xF2
                \x55 \x89\xE5 \x83\xEC\x14 \x50 \xFF\xD2
                \x83\xC4\x10 \xC9 \xE9....
            |
                # ubuntu xenial, gcc 5.4.0, PIC
                \xE8....
                \x81\xC2.... \x55 \x8D\x8A.... \x8D\x82.... \x89\xE5 \x53 \x29\xC8
                \xC1\xF8\x02 \x83\xEC\x04 \x89\xC3 \xC1\xEB\x1F \x01\xD8 \xD1\xF8 \x74\x14
                ...... \x85\xD2 \x74\x0A
                \x83\xEC\x08 \x50 \x51 \xFF\xD2
                \x83\xC4\x10 \x8B\x5D\xFC \xC9 \xC3
            |
                # debian buster, gcc 8.3.0, noPIC
                \xB8.... \x2D....
                \xC1\xF8\x02 \x89\xC2 \xC1\xEA\x1F \x01\xD0 \xD1\xF8 \x74\x20
                \xBA.... \x85\xD2 \x74\x17
                \x55 \x89\xE5 \x83\xEC\x10 \x50 \x68.... \xFF\xD2
                \x83\xC4\x10 \xC9 \xC3
            |
                # debian buster, gcc 8.3.0, PIC
                \xE8....
                \x81\xC2.... \x55 \x89\xE5 \x53
                \x8D\x8A.... \x8D\x82.... \x83\xEC\x04 \x29\xC8 \xC1\xF8\x02
                \x89\xC3 \xC1\xEB\x1F \x01\xD8 \xD1\xF8 \x74\x14
                # mov     edx, offset _ITM_registerTMCloneTable is transformed a lot...
                ...... \x85\xD2 \x74\x0A
                \x83\xEC\x08 \x50 \x51 \xFF\xD2
                \x83\xC4\x10 \x8B\x5D\xFC \xC9 \xC3
        "#,
            ),
            (
                "__do_global_dtors_aux",
                r#"
                # debian jessie, gcc 4.9.2, noPIC
                \x80\x3D....\x00 \x75\x13
                \x55 \x89\xE5 \x83\xEC\x08 \xE8....
                \xC6\x05....\x01 \xC9 \xF3\xC3
            |
                # debian jessie, gcc 4.9.2, PIC
                \x55 \x89\xE5 \x53 \xE8.... \x81\xC3.... \x83\xEC\x04 
                \x80\xBB....\x00 \x75\x27
                \x8B\x83.... \x85\xC0 \x74\x11
                \x83\xEC\x0C \xFF\xB3.... \xE8....
                \x83\xC4\x10 \xE8.... \xC6\x83....\x01 \x8B\x5D\xFC \xC9 \xC3
            |
                # debian buster, gcc 8.3.0, noPIC
                \x80\x3D....\x00 \x75\x17
                \x55 \x89\xE5 \x83\xEC\x08
                \xE8.... \xC6\x05....\x01 \xC9 \xC3
                \x8D\x76\x00
                \xC3
        "#,
            ),
            (
                "frame_dummy",
                r#"
                # debian jessie, gcc 4.9.2, noPIC
                \xB8.... \x8B\x10 \x85\xD2 \x75\x05
                \xEB.
                \x8D\x76\x00
                \xBA.... \x85\xD2 \x74\xF2
                \x55 \x89\xE5 \x83\xEC\x14 \x50 \xFF\xD2
                \x83\xC4\x10 \xC9 \xE9....
            |
                # debian jessie, gcc 4.9.2, PIC
                \x55 \x89\xE5 \x53 \xE8....
                \x81\xC3.... \x83\xEC\x04 \x8D\x83.... \x8B\x10 \x85\xD2 \x75\x12 
                \x8B\x5D\xFC \xC9 \xE9....
                # padding
                \x89\xF6\x8D\xBC\x27\x00\x00\x00\x00
                \x8B\x93.... \x85\xD2 \x74\xE4
                \x83\xEC\x0C \x50 \xFF\xD2
                \x83\xC4\x10 \xEB.
            |
                # ubuntu xenial, gcc 5.4.0, noPIC
                \xB8.... \x8B\x10 \x85\xD2 \x75\x05
                \xEB.
                # padding 
                \x8D\x76\x00
                \xBA.... \x85\xD2 \x74\xF2
                \x55 \x89\xE5 \x83\xEC\x14 \x50 \xFF\xD2
                \x83\xC4\x10 \xC9 \xE9....
            |
                # ubuntu xenial, gcc 5.4.0, PIC
                \xE8....
                \x81\xC2.... \x8D\x82.... \x8B\x08 \x85\xC9 \x75\x09
                \xE9....
                # padding
                \x8D\x74\x26\x00
                ......
                \x85\xD2 \x74\xED
                \x55 \x89\xE5 \x83\xEC\x14 \x50 \xFF\xD2
                \x83\xC4\x10 \xC9 \xE9....
            |
                # debian buster, gcc 8.3.0, noPIC
                \xEB.
            |
                # debian buster, gcc 8.3.0, PIC
                \xE9....
        "#,
            ),
            // those functions are kinda magic and allow any code to be inserted between the epilogue and the prologue
            // we could just match .* between them and hope for best
            // though it seems that this mechanism is VERY outdated and nobody uses it
            // so for a bit stronger guarantees we use a pattern with empty _init and _fini body
            (
                "_init",
                r#"
                # debian jessie, gcc 4.9.2, noPIC
                \x53 \x83\xEC\x08 \xE8....
                \x81\xC3.... \x8B\x83.... \x85\xC0 \x74\x05 \xE8....
                \x83\xC4\x08 \x5B \xC3
            |
                # debian jessie, gcc 4.9.2, PIC
                \x53 \x83\xEC\x08 \xE8....
                \x81\xC3.... \x8B\x83.... \x85\xC0 \x74\x02 \xFF\xD0
                \x83\xC4\x08 \x5B \xC3
        "#,
            ),
            (
                "_fini",
                r#"
                # debian jessie, gcc 4.9.2, noPIC/PIC
                \x53 \x83\xEC\x08 \xE8....
                \x81\xC3....
                \x83\xC4\x08 \x5B \xC3
        "#,
            ),
        ]
        .map(|(k, p)| {
            (
                k,
                RegexBuilder::new(&format!("^({})", p))
                    .dot_matches_new_line(true)
                    .unicode(false)
                    .ignore_whitespace(true)
                    .build()
                    .unwrap(),
            )
        }),
    )
});

pub fn dump_elf_symbols(memory: &MemoryImage, elf: &ElfFile32) -> Result<AddressClasses> {
    use object::read::elf::Sym;
    let e = elf.endianness();

    let sections = elf.raw_header().sections(e, elf.data())?;
    let symbol_table = sections.symbols(e, elf.data(), elf::SHT_SYMTAB)?;

    let mut classes = AddressClasses::new();

    let mut symbols = Vec::new();

    for symbol in symbol_table.iter() {
        // skip undefined symbols
        if symbol.st_shndx.get(e) == elf::SHN_UNDEF {
            continue;
        }

        let address = symbol.st_value.get(e);
        let mut size = symbol.st_size.get(e);
        let name = std::str::from_utf8(symbol.name(e, symbol_table.strings())?)?;
        let kind = symbol.st_type();

        // skip uninteresting symbols
        if matches!(kind, elf::STT_FILE | elf::STT_SECTION | elf::STT_TLS) {
            continue;
        }

        // try to match the unsized symbol against some known functions and if it matches, use the known size
        if size == 0 {
            if let Some(pattern) = KNOWN_FUNCTIONS.get(name) {
                let data = memory.execute_all_at(address);
                if let Some(m) = pattern.find(data) {
                    // the pattern should already include '^' to match from the beginning of the data
                    // but we check just in case
                    assert_eq!(
                        m.start(),
                        0,
                        "BUG: found a match not in the beginning of the data"
                    );
                    debug!(
                        "matched symbol {} at 0x{:08x} to known function variant of size {}",
                        name,
                        address,
                        m.range().len()
                    );
                    size = m.range().len().try_into().unwrap();
                }
            }
        };

        match kind {
            elf::STT_OBJECT | elf::STT_COMMON => classes
                .true_data
                .push(Interval::from_start_and_len(address, size)),
            elf::STT_FUNC => classes
                .true_instructions
                .push(Interval::from_start_and_len(address, size)),
            elf::STT_NOTYPE => {}
            kind => panic!("Unknown symbol type: {}", kind),
        };

        symbols.push((address, size, kind, name));
    }

    symbols.sort();

    for (address, size, kind, name) in symbols {
        let kind_str = match kind {
            elf::STT_OBJECT | elf::STT_COMMON => "data",
            elf::STT_FUNC => "func",
            elf::STT_NOTYPE => "noty",
            kind => panic!("Unknown symbol type: {}", kind),
        };

        if size == 0 && kind == elf::STT_FUNC {
            warn!("zero-sized func symbol: {:08x} {}", address, name);
        } else if kind == elf::STT_NOTYPE && !untyped_ok(name) {
            warn!("        untyped symbol: {:08x} {}", address, name);
        } else {
            debug!(
                "{:08x}-{:08x} {} {}",
                address,
                address + size,
                kind_str,
                name
            );
        }
    }

    Ok(classes)
}
